---
title: 'Re: Life in software engineering from zero: 0x0'
date: 2018-07-30 21:43:44
tags: Re
---

# title: Re: Life in software engineering from zero: 0x0
# 标题: Re: 从零开始的软工生活: 0x0
# タイトル: Re: ゼロからのソフトウェアエンジニアリング: 0x0

本篇面向新生, 大角虫可以忽略, 如有不当, 欢迎指出.

Software Engineering, 简称 SE, 在我院也称 CS. SE 经常要面对十六进制, 十六进制是这样表示的: `0x0`, `0x1`, `0xa`, 分别表示十进制的 0, 1, 10, 以此类推. 下文将使用这样的序数.

[[TOC]]

## 一些政治正确

* 软件的下载请在该软件的官网下载, 而不应该在什么诱导链接很多的下载站, 软件中心下载, 再不济我们还有软件之家. 官网的主要特征: 没有不是自家的软件的广告, 不会有调皮的下载按钮.
* 请不要跟一个前端说 Dreamware.
* 善用搜索引擎. Google 的英文搜索比 baidu 强很多. 能够使用, 学会使用 Google 是基本素养. 再不济英文搜索请使用 bing 的国际搜索.
* 除了一些古老的网站系统, 请使用`现代浏览器`进行网上冲浪.
* 我们的校园网依托于`CERNET`, CERNET 是现在世界上最大的`ipv6`网络, 我们应该为此自豪.

## 0x01: 什么是 Software Engineering?

从字面上理解是进行工程化的软件开发.
这个问题将会在大一第一学期由姜桂飞老师用一个学期的`计算机概论`课来详细解答.
推荐一本书: 《人月神话》

## 0x02: 操作系统

当下的主流操作系统:
* Microsoft Windows
* Unix / Linux
* Mac

苹果的电脑一般配的是 Mac OS, 其他个人电脑一般配的是 Windows, 如果想体验 Linux 可以自己安装, 推荐使用虚拟机体验. Unix 是商用的. Linux 和 Unix 一般用于服务器.

统的来说, 操作系统管理硬件资源, 为用户程序的运行提供运行时支持, 向其暴露系统调用接口( 系统 API ).

注: Amadeus 不属于操作系统.

关于操作系统的底层实现将在大三的课程中教授.

操作系统不难写, 任何一个研究生甚至本科毕业生都有能力实现一个操作系统, 甚至可以做到比 Windows, Linux 更优秀, 但是操作系统不只是一个光盘的事情. 一个系统的普及需要一个不断建立并完善的生态, 需要有人写驱动, 写软件, 这需要钱和时间. 但是我们现在已经有了 Linux 和 Windows, 如果不出现大的问题, 不需要再重复造轮子.

如果你想提前了解浅一些的知识和实现手段( 保证人人可以做到, 不需要本科毕业或是研究生学历 ), 可以查阅:
* <https://www.zhihu.com/question/49580321/answer/287557834>
* <http://blog.jobbole.com/79249/>

## 0x03: 软件

不是所有的软件都有图形界面. Windows 上的软件一般以 *.msi, *.exe 的形式进行分发. Linux 上的软件一般以 *.deb 的形式进行分发. 从直观上看, 没有图形界面的软件以 命令 + 参数 的形式存在.

大一可能用到的软件:
* Visual Studio
* Dev-C++
* CodeBlocks
* Matlab
* Microsoft Office

## 0x04: shell

不太准确地说, shell 是运行非图形界面软件的工具, 也叫 terminal. Unix / Linux 下的shell 为bash, Mac 下叫 termial, Windows 下叫 cmd, 另外 Windows 新推出了 PowerShell.

## 0x05: 开源

开源是一种文化. 将代码公开, 所有人都可以获取代码, 阅读代码, 贡献自己的代码, 参与到软件的开发中来. 与开源密切相关的是开源协议, 主要作用是保障产权, 限制商业化. 参与开源项目, 使用开源代码一定要了解相关开源协议, 并遵守协议, 同时也要明确, 恶意协议是可能存在的. 与开源密切相关的软件有: Git, SVN, 和其他代码管理工具. 比较著名的开源社区有 Github. Git 的释义是饭桶, Git 的常用命令 commit 的释义是犯罪.

## 0x06: 虚拟机

这里指的是用于虚拟一个物理机的软件. 使用这类软件, 可以从当前硬件环境划分出一部分资源, 运行一个与当前操作系统无关的操作系统 ( 需安装 ) , 主流软件有`VirtulBox`, `VMware`. 在虚拟机中安装系统一般需要安装镜像 ( ISO 文件 ).

## 0x07: Unix

Unix 是一个非常成功的系统, 至今仍然运行在许多公司当中. Unix 是商业化的. C 语言诞生于 Unix 的建造过程. 事实上, C 语言重写了 Unix 的第三版内核. 现代计算机系统和软件计量时间普遍使用`Unix时间戳`, Unix 时间戳是起始于 Unix 元年 ( 1970 ) 的秒数西格玛, 在 Unix / linux 下可运行命令`date +%s`获取. 千禧年的危机与 Unix 时间戳无关.

## 0x08: Linux

提到 Linux 不得不提到`Minix`和`Linus`.
>Minix 是一个类 Unix 系统, 起初用于进行大学操作系统课程的教学.  Linus 在 Minix 发行后立即入手了一套, 但是 Minix 低于他的期望值, 于是 Linus 开始着手开发新系统的内核. 这便是 Linux 的诞生.

以上内容来自于《Linus Torvalds 自传》. Intel 悄悄在自家芯片上广泛安装 Minix , 这是后话.

Linux 是开源的. 基于对 开源操作系统的渴求, 许多国家和地区的程序员参与到了 Linux 的开发当中, 贡献了自己的代码. 可以说, Linux 是世界的. 目前 Linux 有许多发行版本, 比较出名的有 CentOS, Ubuntu, Debian, 国内有魔改 Ubuntu 的 Kylin.

## 0x09: Blog  | 博客

建议开设自己的 blog, 好的 blog 在 cs 的圈子里是很有分量的. 优秀的博客软件有 wordpress, typecho, ghost, hexo 等. 可以戳一下以下链接了解形式:
* <http://blog.dimpurr.com>
* <http://rakume.com/blog>

## 0x0a: 现代浏览器

IE 不是现代浏览器. 猎豹, 360急速, UC, 搜狗 之流, 虽有 webkit( 开源的浏览器内核 )之核, 却不是优秀的现代浏览器, 用来购物, 看视频, 打页游倒是挺合适的. 优秀的现代浏览器, 应当支持 w3c( 万维网联盟 ) 发布的新标准, 当下的标志是, 支持 html5 / css3 / es6, WebSocket, WebGL, WebAssembly ( 某前端强烈要求加上: 必须支持 grid 布局). 极致优秀的现代浏览器, 应该有良好的生态环境, 众多可选的安全的扩展插件. 这类浏览器, 才能满足高标准的软件开发者的需求. 定义: 它们是现代浏览器: Firefox, Chrome, Edge, Safari, Opera.

## 0x0b: C

大一上学期开设`高级程序语言设计2-1`, 授课内容是 C 语言( 不是clang ). 相较于其他高级编程语言, C 的年龄稍微大了一点, 但是 C 的运行成本和运行效率仍然是最优秀的, 这也造就了祂的绝对的地位. 在所有的语言里机器语言是成本最低效率最高的, 但是那不应该是现代人写的.

## 0x0c: gcc / g++

gcc, g++ 同属于 GCC(GNU Complier Collection). 一般使用 gcc 编译 C 的源代码, 使用 g++ 编译 C++ 的源代码. 当然 gcc 也可以编译 C++ 的源代码. gcc 的最简单的编译命令:`gcc helloword.c`, linux 下生成默认可执行文件 `a.out`, 通过在shell执行`./a.out`运行, Windows 下生成默认可执行文件`a.exe`, 双击运行或通过在cmd执行`a.exe`运行.

## 0x0d: 小白也应该了解的编译原理

由各种字符堆砌成的源代码由编译器解释为特定的行为, 这就需要一些解释规则. 部分解释规则由语言的保留字( 字面意思 )表示. 比如 C 语言的 `if`, `for`. 保留字的拼写错误将会导致编译错误. 代码中的空格类的字符( 包含 tab 字符, 即便 tab 字符和 blank 字符是不一样的 ) 参与了解释过程, 界定了一个一个的节点, 所以空格类字符不是无用的, 也就是说, 如果缺少了空格将导致编译失败. 半角字符 ( 英文字符 ) 和全角字符 ( 中文字符 ) 是不一样的, C 语言的保留字是半角字符, 误用全角字符, 在应该使用英文字符的位置使用了中文字符, 将导致编译失败. 以上的错误是新手遭遇编译错误的主要原因.

## 0x0e: IDE

IDE, 集成开发环境. 一般包含了编译套件, 也有不包含编译套件的. IDE 提供了包含代码编辑, 编译链接, 调试测试, 版本管理等功能. 常见的 IDE: Visual Studio, CodeBlocks 等.

不少代码编辑器虽然挂着编辑器的名字, 但是稍加配置就能成为功能强大的IDE, 比如: vim, sublime text, atom, visual studio code 等. 以上提到的 4 种编辑器生态都比较完整, 其中 atom 由 github 官方开源打造, visual studio code 由微软官方维护, 这两款比较现代化.

推荐在 ACM-ICPC 中使用的 IDE 为 codeblocks.

## 0x0f: 算法

Algorithm. 在一定的时间和空间( 内存 )内解决问题的程序语句的集合. 在数学和计算机科学中, 一种算法是一种解决一类问题的明确的详细描述. 它是有效的方法, 一种算法能够表达为在特定时间, 空间内定义完备的函数. 算法可以描述为流程图, 自然语言, 伪代码, 特定编程语言的代码. 通常表现形式为对给定输入产生正确的输出. 例如:
```
A+B Problem
Caculate A+B.
input:
1 1
output:
2
```
说白了就是把解的过程写成代码, 把答作为程序输出.

算法运行于特定的机器上, 消耗时间和空间, 因此必须考虑成本. 成本被描述为复杂度, 成本越高, 复杂度越大. 最常用的复杂度表示为大 O 记号, 即数量级的渐进的上界. 1 个变量的空间复杂度为 O(1), n, 2n, 3n 个变量的空间复杂度为 O(n), n * n, 2 * n * n 个变量的空间复杂度为 O(n^2). 一条 cpu 指令的时间复杂度为 O(1), 一个从 1 到 n 的循环的时间复杂度为 O(n), 循环中再嵌套一个循环的时间复杂度为 O(n^2), 一个二分的递归的时间复杂度为 O(lg n). 一个优秀的算法应该将时间复杂度和空间复杂度降到最低.

## 0x10: ACM-ICPC

ACM-ICPC, 通常称 ICPC. ACM, Association for Computing Machinery, 国际计算机协会.
ICPC, International Collegiate Programming Contest, 国际大学生程序设计竞赛. ICPC 的起点可以追溯到 unix元年, 也就是 1970 年. 现在的 ICPC 由 ACM 举办, 因此称 ACM-ICPC. 基本形式: 每队三人, 使用一台机器, 在五个小时内解决数道程序设计题目. ICPC 主要考察算法设计( 使用 )能力. ICPC 层层筛选, 从网络赛到现场赛, 从区域赛到国赛, 再到洲赛, 最后到世界总决赛. 通过重重考验的勇士将最终站在神话的顶峰 ( 虽然说冠军被北方某个数学很强的国家常年把持 ).
* ICPC 的判题机制在下一条目介绍.
* 现在 ICPC 现场赛的计算机统一安排 linux 的发行版 Ubuntu, 桌面软件为 Unity, 如果想感受比赛的氛围可以戳: <https://search.bilibili.com/all?keyword=ACM-ICPC>
* ICPC 的题目编号一般为 ABCD 等按顺序的英文大写字母, 题目有标题, 通常比较正式的比赛的题目标题不会太调皮. 题量为 G 个题或以上. 题面为英文, 比较容易读懂, 比较正式的比赛的题面不会太调皮, 可能会配图, 画风通常比较亲民.
* ICPC 的区域以上赛事每年在不同的地点举办, 通常赛事的名称中会包含举办地点的名字.
* 当一个队伍成功 ac( 正确解决 ) 了一道题, 这个队伍将得到一个气球. 通常不同题目的气球颜色不一样. 神级的队伍经常吐槽升起的气球蒙蔽了他们的双眼.
* 可以将任何纸质资料带进赛场, 包括大英百科全书和福音书.
* 你现在做的题目可能是你对面的学校出的.
* 签到题. 一套优秀的题目必然有签到题, 通常难度非常低, 比 A+B 还低, 比如说非常温暖人心的后缀数组.
* 防 ak 题. 即防止完全 ac 的题. 一套优秀的题目必然有防 ak 题. 通常难度非常高, 比 A+B 还高, 比如碧蓝航线.
* 水题: 难度介于签到题和防 ak 题之间的题目.
* 榜. ICPC 的榜上会显示队伍的排名, 队伍解决的题目, 尝试解决的题目, 解决时间. 跟着榜做题是比较明智的做法, 在榜没被带歪的时候.
* 封榜. 榜在比赛的最后半小时将不会再更新.
* 通常 JAVA 有两倍的时间限制和内存限制, 但这不意味着使用 JAVA 可以比 C / C++ 更轻松.
* 校 ACM 有个超大的实验室, 院 ACM 也有一个超大的实验室.

## 0x11: OJ

OJ, Online Judge. 用户向 OJ 提交相应题目的代码, OJ 在后台评判用户提交的答案代码, 并返还给用户正确性.

一个完整的 OJ 大致包括这些东西:

* 题库, 通常从编号 1001 的题目开始. 通常 1001 为 `A+B Problem`. 一道完整的题目包含题面, 输入数据, 输出数据. 通常只向用户透露少量的输入输出数据. 一些平台会提供完整的输入输出数据,题解和标程( 标准程序 ). 现代化的 OJ 允许用户线上测试自己提供的输入数据.
* 状态. 显示提交到平台上的代码的测试情况.
* 评测机. 即评测姬. 泛指一套编译链接执行用户提交代码, 比对用户代码输出和正确输出, 并返还状态的系统.

题目是有时间和内存限制的, 也就是通常说的卡时间, 卡内存. 题目可能有多组测试数据, 也可能只有一组测试数据. 用户提交的代码长度通常也是有限制的, 但是一般不会影响正确解题. 用户在前端提交的代码, 通过网络传输到 OJ 后端. 代码将被评测机编译链接生成可执行文件, 可执行文件将被启动, 同时监视程序也将启动. 监视程序阻止危险指令的运行, 在程序执行时间空间超过限制时终止程序运行, 并记录程序的时间空间消耗. 题目的输入数据被重定向到程序中, 程序的输出被重定向到指定文件中. 如果运行无异常, 评测机将比对程序输出和正确输出, 然后将结果通过网络传输回用户前端.

常见的评测结果:

* Accept. 也就是 ac. ACMer 能够熟练地使用此缩写词的使动用法. 例: 我 ac 了这道水题!
* Wrong Answer.也就是 wa. 用法同上. 例: 我 wa 掉了这道防 ak 题!
* Presentation Error. 也就是 pe. 这是赛场上最冤的失误, 仅仅是输出结果的格式与题目要求不符, 通常表现为少输出一个空格, 一个回车. 但是也有调皮的评测姬会将 wa 判为 pe, 让你在修改输出为正确格式后再 wa 地哭出声来.
* Compilation Error. 这是评测姬最不愿看到的评测结果. 麻烦用户姥爷在本地编译通过了再提交代码. 但是也会有其他情况导致 ce, 比如说选错了语言, 或者使用了 C++11 的语法但是评测姬不支持.
* Runtime Error. 运行时错误. 通常为操作了不被允许的内存, 表现为数组越界, 指针误用.
* Time Limit Exceeded. 即 tle. 超时了, 改改算法吧.
* Memory Limit Execeeded. 即 mle. 空间超限了, 赶紧修改一下你的数据结构.
* Function Limit Execeeded. 使用了不被允许的函数.


南开大学的 Online Judge 由 `南开大学ACM协会` 运行维护, 暂不向广域网开放.
南开新 OJ( 尚未完成题目迁移 ): <http://acm.nankai.edu.cn>
南开旧 OJ( 题量丰富 ): <http://acm.nankai.edu.cn/old>

南开现存的OJ还有`nkcoj`, `南开大学软件学院OJ系统`.

## 0x12: 安装使用 codeblocks( Windows )

推荐使用 codeblocks 进行 C / C++ 的开发. 戳 <https://nchc.dl.sourceforge.net/project/codeblocks/Binaries/17.12/Windows/codeblocks-17.12mingw-setup.exe> 下载codeblocks. 这个安装包已经包含了 TDM-GCC 编译套件. 大小应该在 86MB 左右. 下载完成后, 运行这个 exe 文件. 依次选择按钮`Next -> I Agree -> Next`, 这时来到安装位置选择. 如果你的电脑有固态硬盘, 推荐安装到固态硬盘, 否则不建议安装到 C 盘. 选择好位置后按下`Install`, 安装开始. 推荐在一个磁盘下, 不同软件安装到同一个目录下的不同名目录中, 便于管理. 安装完成, 弹出是否立刻启动 codeblocks 的选择框, 视情况选择.

开始使用CodeBlocks.

启动 CodeBlocks. 它在桌面的图标为四色四方块. 我们尚未到达工程化开发的的境界, 因此选择菜单: `File -> New -> File...`, 弹出选择框, 选择`C/C++ source`, 按下`Go`按钮, 来到向导第一页, 按下`Next`, 来到语言选择, 选择`C`, 按下`Next`, 来到文件保存路径和文件名设置, 按下`...`, 选择位置并填写文件名, 比如说`hw.c`, 点击保存, 回到向导, 按下`Finish`按钮.

这时编辑区域已经打开`hw.c`文件.输入:
```C
#include <stdio.h>
int main(int argc, char **argv, char **envp){
  printf("hello world");
  return 0;
}
```
按下`Ctrl + S`保存. 点击控件栏的黄色齿轮和绿色三角形叠在一起的`Build and Run`按钮, 或选择菜单栏的`Build -> Build and Run`, 或者按下 `F9`. 此时文件自动保存, 编译链接生成可执行文件并运行. 然后你将看到一个黑洞洞的窗口和白色的字. 如果你不喜欢这样的颜色, 你可以右键点击黑洞洞窗口的标题, 选择右键菜单的`默认值`, 调节颜色. 设置将在下一次构建运行生效.

如果想体验工程化开发, 可以选择菜单栏`File -> New -> Project...`, 在选择菜单中选择`Console Application`.

## 0x13: 前端学习路线指北

前端, Front End. 常指一个行业, 也作从事这一行业的 coder 的代词. 前端指网站和应用的界面设计和相关的业务处理. 前端的发展瞬息万变, 一个前端最烦的是学了还要学, 最害怕的是落后于这个时代. 一个前端的前端之路, 应当从最基础的`html / css / js`开始. 现在 html 发展到了 html5, css 发展到了 css3, js 发展到了 es6, es7, 而 es8 即将问世( es7 相较于es6 没有太大变化 ). 然后要了解`nodejs`. 学习完它们之后, 开始学习框架. 比较好的 UI 框架有 bootstrap, `semantic UI`. 比较好的 js 框架有 `vue`, react. 然后可以学习 w3c 刚发布的一些标准, 比如说 WebGL, WebSocket, Web Audio API, 或者是全新的布局方案, 比如说 grid 布局. 结合 nodejs 进行工程化开发, 此时你在技术层面上已经走在行业的前端了. 但是这些过程隐藏了一点, 那就是设计. 一个好的前端, 不仅要有充足的浏览量, 掌握一些设计语言, 有自己的审美, 能够感受美, 创造美, 还要能够在阳春白雪和下里巴人中找到一个平衡点, 这是最难的. 一个好的前端, 应能代表先进的文化艺术的发展方向.

## 0x14: 后端学习路线指北

后端, Back End. 首先要学习 linux 和 shell 的使用. 了解 http, DNS 一类的网络通识. 然后学习 Nginx, Apache 一类的服务器软件. 然后学习 nodejs, 学习数据库. 学习一些框架, 比如说 express, graphql. 目前 github, twitter 都在使用 graphql. 当然也有一些现成的整套的后端框架, 比如说 feathers.

## 0x15: Hello World

* javascript

打开浏览器, 按下F12, 在 console 输入`console.log('hello world')`.
* javascript

打开浏览器, 在地址栏输入`javascript:document.write('hello world');`, 然后回车.
* C
```C
#include <stdio.h>
int main(int argc, char **argv, char **envp){
  printf("hello world");
  return 0;
}
```
* C++
```Cpp
#include <iostream>
using namespace std;
int main(int argc, char **argv, char **envp){
  cout<<"hello world"<<endl;
  return 0;
}
```
* cmd( windows )

创建一个文本文件,编辑:
```bash
@echo off
@echo hello world
pause
```
另存为`1.bat`, 双击运行.
* bash( linux / mac)

在终端中执行命令`vim hw.sh`. 然后就会启动大名鼎鼎的vim. 按下`i`, 进入输入模式. 输入:
```bash
echo hello world
```
按下键盘最左上角的`Esc`, 进入命令模式, 输入`:wq`, 回车, 退出vim, 回到bash. 输入命令`bash hw.sh`.
