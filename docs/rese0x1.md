---
title: 'Re: Life in software engineering from zero: 0x1'
date: 2018-10-22 21:43:44
tags: Re
---

# title: Re: Life in software engineering from zero  
# 标题: Re: 从零开始的软工生活  
# タイトル: Re: ゼロからのソフトウェアエンジニアリング

### 主题

程序设计

### 0x0

以下为可选项：
* 人类语言的发展历程有哪些不平常的事？比如：统一，变革。
* 假设你是 boss，你需要你的员工们完成一项工作，你留下的指令他们一定会正确地执行，但是你一次性下达全部指令之后就会与他们失联，你需要留下什么样的指令才能确保万无一失（这个万无一失包括但不限于资源，效率，正确性）？
* 承上，如果在指令下达之后，你可以多次增删改全部指令，这样的意义何在？不行我编不下去了。
* 综上考虑，假设你是设计人类语言的工程师，你认为这门语言应该是什么样的？
* 回忆一下初中学过的二进制，检测自己是否还会进行进制转换。
* 大概了解一下低级语言、高级语言（指程序设计）。

### 0x1 机器语言的介绍

* 二进制
* 逻辑门
  * 与或非
  * 半加器
* 查看二进制代码：vim + xxd。
  * :%xxd,:%xxd -r
  * xxd filename

> 维基百科
>> 机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。机器语言具有灵活、直接执行和速度快等特点。不同种类的计算机其机器语言是不相通的，按某种计算机的机器指令编制的程序不能在另一种计算机上执行。
要用机器语言编写程序，编程人员需首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员要自己处理每条指令和每一数据的存储分配和输入输出，还需记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作，编写程序花费的时间往往是实际运行时间的几十倍或几百倍。而且，这样编写出的程序完全是0与1的指令代码，可读性差且容易出错。在现今，除了计算机生产厂家的专业人员外，绝大多数程序员已经不再学习机器语言。


### 0x2 汇编语言介绍

软件：nasm 汇编器。
生成汇编代码：g++：`g++ -S file.c`，gcc: `gcc -S file.c`。（AT&T风格）  
`-fverbose-asm`可以获取变量注释。  
开启`-O2`可去除冗余信息。  

> 维基百科
>> 是一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。
使用汇编语言编写的源代码，然后通过相应的汇编程序将它们转换成可执行的机器代码。这一过程被称为汇编过程。
汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。特定的汇编目标指令集可能会包括特定的操作数。许多汇编程序可以识别代表地址和常量的标签（Label）和符号（Symbols），这样就可以用字符来代表操作数而无需采取写死的方式。普遍地说，每一种特定的汇编语言和其特定的机器语言指令集是一一对应的。
许多汇编程序为程序开发、汇编控制、辅助调试提供了额外的支持机制。有的汇编语言编写工具经常会提供宏，它们也被称为宏汇编器。
现在汇编语言已不像其他大多数的程序设计语言一样被广泛用于程序设计，在今天的实际应用中，它通常被应用在底层硬件操作和高要求的程序优化的场合。驱动程序、嵌入式操作系统和实时运行程序都会需要汇编语言。

> wiki
> 

|项目|形式|
|--|--|
|操作数顺序	|源操作数在前|
|寄存器名字	|加%前缀|
|立即数		|加$前缀|
|16进制立即数	|加前缀0x|
|访问内存长度的表示	|后缀b、w、l表示字节、字、长型|

|项目|形式|
|--|--|
|引用全局或静态变量var的值	 | `_var` |
|引用全局或静态变量var的地址	 |`$_var`|
|引用局部变量	|需要基于栈指针（ESP）|
|内存直接寻址	|`seg_reg: immed32 (base, index, scale)`|
|寄存器间址	 |(%reg)|
|寄存器变址寻址	 |`_x(%reg)`|
|立即数变址寻址	|`1(%reg)`|
|整数数组寻址	 |`array (,%eax, 4)`|

https://akaedu.github.io/book/ch18s01.html

来看一个普通的汇编程序。

```
.section .data
.section .text
.global _start # .*:汇编指示，伪操作
_start:
  movl $1, %eax
  movl $141, %ebx
  int $0x80 # 产生一个软中断指令，在用户程序看来和 return 一样

```
```
as hw.s -o hw.o
ld hw.o -o hw
./hw
echo %?
```
eax, ebx 都是寄存器，`int 0x80`产生一个异常，这个由`0x80`指向的系统调用接管，这时 eax 被当作系统调用号，指向 _exit，ebx 被当成传给 ebx 的参数。

> int指令称为软中断指令，可以用这条指令故意产生一个异常，上一章讲过，异常的处理和中断类似，CPU从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序。

> int指令中的立即数0x80是一个参数，在异常处理程序中要根据这个参数决定如何处理，在Linux内核中int $0x80这种异常称为系统调用（System Call）。内核提供了很多系统服务供用户程序使用，但这些系统服务不能像库函数（比如printf）那样调用，因为在执行用户程序时CPU处于用户模式，不能直接调用内核函数，所以需要通过系统调用切换CPU模式，经由异常处理程序进入内核，用户程序只能通过寄存器传几个参数，之后就要按内核设计好的代码路线走，而不能由用户程序随心所欲，想调哪个内核函数就调哪个内核函数，这样可以保证系统服务被安全地调用。在调用结束之后，CPU再切换回用户模式，继续执行int $0x80的下一条指令，在用户程序看来就像函数调用和返回一样。

> eax和ebx的值是传递给系统调用的两个参数。eax的值是系统调用号，Linux的各种系统调用都是由int $0x80指令引发的，内核需要通过eax判断用户要调哪个系统调用，_exit的系统调用号是1。ebx的值是传给_exit的参数，表示退出状态。大多数系统调用完成之后会返回用户空间继续执行后面的指令，而_exit系统调用比较特殊，它会终止掉当前进程，而不是返回用户空间继续执行。


### 低级语言

https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80

一般指机器语言和汇编语言。和 cpu 的指令集系统息息相关，非常接近硬件，写出的软件相对不可移植。

优点是运行速度非常快，内存占用少。

### 0x4 目标文件，可执行文件

#### 目标文件的组织形式的基本思路

实际的会更加复杂。

* ELF文件头，exec header
* 文本段，程序代码，text segment
* 数据段，程序数据，data segment
* 重定位段，分为 text 和 data 的 relocations
* 符号表，函数，变量名，symbol table
* 字符串表： 字符串信息。string table

目标文件本身就是二进制文件。

### 0x5 高级语言与低级语言

编辑 main.c。
```
int main(){
  int a=0;
  return a;
}
```
产生中间文件 *.o

`gcc -c -O2 main.c -o main.o`

生成汇编文件 *.s

`gcc -S -O2 main.c -o main.s`

查看汇编代码

`cat main.s`
```
        .file   "main.c"
        .section        .text.startup,"ax",@progbits
        .p2align 4,,15
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        movl    $1, %eax
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
        .section        .note.GNU-stack,"",@progbits
```        

查看反汇编代码

`objdump -d main.o`

```

main.o:     file format elf64-x86-64


Disassembly of section .text.startup:

0000000000000000 <main>:
   0:   b8 01 00 00 00          mov    $0x1,%eax
   5:   c3                      retq
```
生成可执行文件

`gcc main.c -o main`

执行

`./main`

查看返回值

`echo $?`

查看可执行文件的组织形式

`objdump -h main`

要素过多，我们关注：
`.data`, 数据段， `.bss`, 未初始化数据，`.text`, 代码段，`.rodata`, 只读代码段。

### 0x6高级语言

C 很接近底层，C 语言编译的程序在相同的架构、系统上可以运行，在同系统、不同架构的上需要重新编译，但是基本不需要修改源代码，在不同系统上需要修改代码，重新编译。C 也很快，C 是很接近低级语言的高级语言，C 语言不像低级语言那样极端依赖硬件。

高级语言具有机器无关性，一条高级语言语句往往由若干机器语言实现且不具有对应性。其形式接近自然语言，易于理解。

#### 分类

* 命令式语言（结构化语言）（OPP）。C，Fortran，Pascal。
* 面向对象语言（OOP）。一个重要的特征是 class，类。C++，C#，Java。
* 函数式语言。Haskell。函数是第一等公民，只有表达式没有语句。
* 逻辑语言。Prolog。

### debug

#### gdb

* 变量查看
* 断点
* 步进

使用 gcc 编译时使用 `-g` 生成调试符号。

使用方式：

`gdb filename`

查看与代码：

`l`,`list`,`l 1,4`

设置断点：

`tbreak`,将下一行设为临时断点，`b`,将下一行设为断点，后可以接函数名，行数。
`disable`,`enable`,`d`,后接编号，`ignore pos times`。
`info`,查看所有断点。
可加条件：`if * * *

执行：
`r`

单步执行：
`n`，不跟踪到函数内部，`s`，跟踪到函数内部。

继续到止：
`finish`

继续到下一断点：
`c`

堆栈：
`where`,`frame`

查看变量：
`info locals`,`info args`,`p a`

### 0x7 something

av22824043

https://hellogithub.com/report/tiobe/

https://octoverse.github.com/

github 是世界上最大的代码存放网站和开源社区。




